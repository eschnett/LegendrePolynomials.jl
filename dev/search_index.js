var documenterSearchIndex = {"docs":
[{"location":"derivatives/#Derivatives-of-Legendre-Polynomials","page":"Derivatives","title":"Derivatives of Legendre Polynomials","text":"","category":"section"},{"location":"derivatives/","page":"Derivatives","title":"Derivatives","text":"The Julia automatic differentiation framework may be used to compute the derivatives of Legendre polynomials alongside their values. Since the defintions of the polynomials are completely general, they may be called with dual or hyperdual numbers as arguments to evaluate derivarives in one go.  We demonstrate one example of this using the package HyperDualNumbers.jl v4:","category":"page"},{"location":"derivatives/","page":"Derivatives","title":"Derivatives","text":"DocTestSetup = quote\n\tusing LegendrePolynomials\nend","category":"page"},{"location":"derivatives/","page":"Derivatives","title":"Derivatives","text":"julia> x = 0.5;\n\njulia> Pl(x, 3)\n-0.4375\n\njulia> using HyperDualNumbers\n\njulia> xh = Hyper(x, one(x), one(x), zero(x));\n\njulia> p = Pl(xh, 3)\n-0.4375 + 0.375ε₁ + 0.375ε₂ + 7.5ε₁ε₂","category":"page"},{"location":"derivatives/","page":"Derivatives","title":"Derivatives","text":"The Legendre polynomial P_ell(x) may be obtained using ","category":"page"},{"location":"derivatives/","page":"Derivatives","title":"Derivatives","text":"julia> realpart(p)\n-0.4375","category":"page"},{"location":"derivatives/","page":"Derivatives","title":"Derivatives","text":"The first derivative dP_ell(x)dx may be obtained as ","category":"page"},{"location":"derivatives/","page":"Derivatives","title":"Derivatives","text":"julia> ε₁part(p)\n0.375","category":"page"},{"location":"derivatives/","page":"Derivatives","title":"Derivatives","text":"The second derivative d^2P_ell(x)dx^2 may be obtained using ","category":"page"},{"location":"derivatives/","page":"Derivatives","title":"Derivatives","text":"julia> ε₁ε₂part(p)\n7.5","category":"page"},{"location":"derivatives/","page":"Derivatives","title":"Derivatives","text":"Something similar may also be evaluated for all l iteratively. For example, the function collectPl evaluates Legendre polynomials for the HyperDualNumber argument for a range of l:","category":"page"},{"location":"derivatives/","page":"Derivatives","title":"Derivatives","text":"julia> collectPl(xh, lmax=4)\n5-element OffsetArray(::Array{Hyper{Float64},1}, 0:4) with eltype Hyper{Float64} with indices 0:4:\n                1.0 + 0.0ε₁ + 0.0ε₂ + 0.0ε₁ε₂\n                0.5 + 1.0ε₁ + 1.0ε₂ + 0.0ε₁ε₂\n             -0.125 + 1.5ε₁ + 1.5ε₂ + 3.0ε₁ε₂\n        -0.4375 + 0.375ε₁ + 0.375ε₂ + 7.5ε₁ε₂\n -0.2890625 - 1.5625ε₁ - 1.5625ε₂ + 5.625ε₁ε₂","category":"page"},{"location":"derivatives/","page":"Derivatives","title":"Derivatives","text":"We may extract the first derivatives by broadcasting the function ε₁part on the array as:","category":"page"},{"location":"derivatives/","page":"Derivatives","title":"Derivatives","text":"julia> ε₁part.(collectPl(xh, lmax=4))\n5-element OffsetArray(::Array{Float64,1}, 0:4) with eltype Float64 with indices 0:4:\n  0.0\n  1.0\n  1.5\n  0.375\n -1.5625","category":"page"},{"location":"derivatives/","page":"Derivatives","title":"Derivatives","text":"Similarly the function ε₁ε₂part may be used to obtain the second derivatives. ","category":"page"},{"location":"derivatives/","page":"Derivatives","title":"Derivatives","text":"Several convenience functions to compute the derivatives of Legendre polynomials were available in LegendrePolynomials v0.2, but have been removed in v0.3. The users are encouraged to implement convenience functions to extract the derivatives as necessary. As an exmaple, we may compute the polynomials and their first and second derivatives together as","category":"page"},{"location":"derivatives/","page":"Derivatives","title":"Derivatives","text":"julia> using HyperDualNumbers\n\njulia> function Pl_dPl_d2Pl(x; lmax)\n           xh = Hyper(x, one(x), one(x), zero(x))\n           p = collectPl(xh, lmax = lmax)\n           realpart.(p), ε₁part.(p), ε₁ε₂part.(p)\n       end\nPl_dPl_d2Pl (generic function with 1 method)\n\njulia> Pl_dPl_d2Pl(0.5, lmax = 3)\n([1.0, 0.5, -0.125, -0.4375], [0.0, 1.0, 1.5, 0.375], [0.0, 0.0, 3.0, 7.5])","category":"page"},{"location":"derivatives/#Analytical-approach-for-higher-derivatives","page":"Derivatives","title":"Analytical approach for higher derivatives","text":"","category":"section"},{"location":"derivatives/","page":"Derivatives","title":"Derivatives","text":"Legendre polynomials satisfy the differential equation ","category":"page"},{"location":"derivatives/","page":"Derivatives","title":"Derivatives","text":"fracddxleft(1-x^2)fracd P_ndx right + n(n+1) P_n(x) = 0","category":"page"},{"location":"derivatives/","page":"Derivatives","title":"Derivatives","text":"We may rearrange the terms to obtain ","category":"page"},{"location":"derivatives/","page":"Derivatives","title":"Derivatives","text":"fracd^2 P_ndx^2 = frac1(1-x^2)left( 2x fracd P_n(x)dx - n(n+1)P_nx right)","category":"page"},{"location":"derivatives/","page":"Derivatives","title":"Derivatives","text":"We may therefore compute the second derivative from the function and its first derivative. Higher derivatives may further be computed in terms of the lower ones.","category":"page"},{"location":"derivatives/","page":"Derivatives","title":"Derivatives","text":"We demonstrate the second-derivative computation using the package DualNumbers.jl v0.5: ","category":"page"},{"location":"derivatives/","page":"Derivatives","title":"Derivatives","text":"julia> using DualNumbers\n\njulia> x = 0.5;\n\njulia> xd = Dual(x, one(x));\n\njulia> d2Pl(x, P, dP, n) = (2x * dP - n*(n+1) * P)/(1 - x^2);\n\njulia> function d2Pl(x, n)\n           xd = Dual(x, one(x))\n           y = Pl(xd, n)\n           P, dP = realpart(y), dualpart(y)\n           d2Pl(x, P, dP, n)\n       end;\n\njulia> d2Pl(x, 20)\n32.838787646905985","category":"page"},{"location":"derivatives/","page":"Derivatives","title":"Derivatives","text":"We may check that this matches the result obtained using HyperDualNumbers:","category":"page"},{"location":"derivatives/","page":"Derivatives","title":"Derivatives","text":"julia> ε₁ε₂part(Pl(xh, 20))\n32.838787646905985","category":"page"},{"location":"derivatives/","page":"Derivatives","title":"Derivatives","text":"Unfortunately at this point, higher derivatives need to be evaluated analytically and expresed in terms of lower derivatives.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"CurrentModule = LegendrePolynomials\nDocTestSetup = quote\n\tusing LegendrePolynomials\nend","category":"page"},{"location":"#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Compute Legendre polynomials using a 3-term recursion relation (Bonnet’s recursion formula).","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"P_ell(x) = left((2ell-1) x P_ell-1(x) - (ell-1)P_ell - 2(x)right)ell","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Currently this package evaluates the standard polynomials that satisfy P_ell(1) = 1 and P_0(x) = 1. These are normalized as ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"int_-1^1 P_m(x) P_n(x) dx = frac22n+1 delta_mn","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"There are two main functions: ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Pl(x,l): this evaluates the Legendre polynomial for a given degree l at the argument x. The argument needs to satisfy -1 <= x <= 1.\ncollectPl(x; lmax): this evaluates all the polynomials for l lying in 0:lmax at the argument x. As before the argument needs to lie in the domain of validity. Functionally this is equivalent to Pl.(x, 0:lmax), except collectPl evaluates the result in one pass, and is therefore faster. There is also the in-place version collectPl! that uses a pre-allocated array.","category":"page"},{"location":"#Quick-Start","page":"Introduction","title":"Quick Start","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Evaluate the Legendre polynomial for one l at an argumentx as Pl(x, l):","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"julia> Pl(0.5, 3)\n-0.4375","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Evaluate all the polynomials for l in 0:lmax as ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"julia> collectPl(0.5, lmax = 3)\n4-element OffsetArray(::Array{Float64,1}, 0:3) with eltype Float64 with indices 0:3:\n  1.0\n  0.5\n -0.125\n -0.4375","category":"page"},{"location":"#Increase-precision","page":"Introduction","title":"Increase precision","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"The precision of the result may be changed by using arbitrary-precision types such as BigFloat. For example, using Float64 arguments we obtain","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"julia> Pl(1/3, 5)\n0.33333333333333337","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"whereas using BigFloat, we obtain","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"julia> Pl(big(1)/3, 5)\n0.3333333333333333333333333333333333333333333333333333333333333333333333333333305","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The precision of the latter may be altered using setprecision, as ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"julia> setprecision(300) do \n       Pl(big(1)/3, 5)\n       end\n0.33333333333333333333333333333333333333333333333333333333333333333333333333333333333333333317","category":"page"},{"location":"#Reference","page":"Introduction","title":"Reference","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Modules = [LegendrePolynomials]","category":"page"},{"location":"#LegendrePolynomials.LegendrePolynomialIterator","page":"Introduction","title":"LegendrePolynomials.LegendrePolynomialIterator","text":"LegendrePolynomialIterator(x, [lmax::Integer])\n\nReturn an iterator that generates the values of the Legendre polynomials P_l(x) for the given x. If lmax is specified then only the values of P_l(x) from 0 to lmax are returned.\n\nExamples\n\njulia> import LegendrePolynomials: LegendrePolynomialIterator\n\njulia> iter = LegendrePolynomialIterator(0.5, 4);\n\njulia> collect(iter)\n5-element OffsetArray(::Array{Float64,1}, 0:4) with eltype Float64 with indices 0:4:\n  1.0\n  0.5\n -0.125\n -0.4375\n -0.2890625\n\njulia> iter = LegendrePolynomialIterator(0.5);\n\njulia> collect(Iterators.take(iter, 5)) # evaluete 5 elements (l = 0:4)\n5-element Array{Float64,1}:\n  1.0\n  0.5\n -0.125\n -0.4375\n -0.2890625\n\njulia> collect(Iterators.take(Iterators.drop(iter, 100), 5)) # evaluate Pl for l = 100:104\n5-element Array{Float64,1}:\n -0.0605180259618612\n  0.02196749072249231\n  0.08178451892628381\n  0.05963329258495025\n -0.021651535258316177\n\n\n\n\n\n","category":"type"},{"location":"#LegendrePolynomials.Pl-Tuple{Any,Integer}","page":"Introduction","title":"LegendrePolynomials.Pl","text":"Pl(x, l::Integer)\n\nCompute the Legendre Polynomial P_l(x) for the argument x and the degree l\n\nExamples\n\njulia> Pl(1, 2)\n1.0\n\njulia> Pl(0.5, 20)\n-0.04835838106737356\n\n\n\n\n\n","category":"method"},{"location":"#LegendrePolynomials.collectPl!-Tuple{AbstractArray{T,1} where T,Any}","page":"Introduction","title":"LegendrePolynomials.collectPl!","text":"collectPl!(v::AbstractVector, x; [lmax::Integer = length(v) - 1])\n\nCompute the Legendre Polynomials P_l(x) for the argument x and all degrees l in 0:lmax,  and store them in v.\n\nAt output v[firstindex(v) + l] == Pl(x,l).\n\nExamples\n\njulia> v = zeros(4);\n\njulia> collectPl!(v, 0.5)\n4-element Array{Float64,1}:\n  1.0\n  0.5\n -0.125\n -0.4375\n\njulia> v = zeros(0:4);\n\njulia> collectPl!(v, 0.5, lmax = 3) # only l from 0 to 3 are populated\n5-element OffsetArray(::Array{Float64,1}, 0:4) with eltype Float64 with indices 0:4:\n  1.0\n  0.5\n -0.125\n -0.4375\n  0.0\n\n\n\n\n\n","category":"method"},{"location":"#LegendrePolynomials.collectPl-Tuple{Any}","page":"Introduction","title":"LegendrePolynomials.collectPl","text":"collectPl(x; lmax::Integer)\n\nCompute the Legendre Polynomial P_l(x) for the argument x and all degrees l in 0:lmax. Return an OffsetArray P with indices 0:lmax, where P[l] == Pl(x,l)\n\nExamples\n\njulia> collectPl(0.5, lmax = 4)\n5-element OffsetArray(::Array{Float64,1}, 0:4) with eltype Float64 with indices 0:4:\n  1.0\n  0.5\n -0.125\n -0.4375\n -0.2890625\n\n\n\n\n\n","category":"method"}]
}
